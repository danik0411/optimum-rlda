# read and analyse sonar.txt
# rm(list=ls(all=TRUE))	# clear all environments

applyAllEstimators = function( data_filename ) {

startTime = proc.time();

source("double.R");
source("CV.R");
source("plugin.R")
source("loo.R");
source("trueError.R");

myEnv = new.env();	# store functions in this environment

environment( CV ) = myEnv;
environment( estimateErrorDouble ) = myEnv;
environment( RLDAvalue ) = myEnv;
environment( estimateD ) = myEnv;
environment( estimateTrueError ) = myEnv;
environment( LABELS_FROM_LDA_FUNCTION ) = myEnv;
environment( compareClassifierOutputs ) = myEnv;
environment( loo ) = myEnv;
environment( plugin_lda ) = myEnv;

myRun = "test";

if ( myRun == "test" ) {
   sampleSize = seq(30 , 50, by=10);
   repetition = 5;
   gammaValues = 1:3;
print("running in test mode");
} else if ( myRun == "real" ) {
  sampleSize = seq(30,120,by=10);
  repetition=500;
  gammaBase = 100^(1/20);
  gammaValues = gammaBase^c(-10:20);
  print("running in real mode");
}

# load("testsynth_sampleNumbers.RData");
load( data_filename );
kappa = 1;
checkValue = 0;

rows = dim( Data )[1];
uns = dim( Data )[2];
orgClasses = unique( Data[ rows , ] );

# Data = data;
# Data[ rows , Data[ rows , ] == orgClasses[1] ] = 0;
# Data[ rows , Data[ rows , ] == orgClasses[2] ] = 1;

classes = c( 0 , 1 );

# Data = array( as.numeric( Data ) , dim = c ( rows , uns ) );

dataWithLabels = Data;
dataWithoutLabels = Data[ -rows , ];

labelRow = Data[rows , ];

sample0 = which( labelRow %in% classes[1] );	# position of class0 in data
sample1 = which( labelRow %in% classes[2] );	# position of class1 in data

un0 = length( sample0 );
un1 = length( sample1 );
uns = c ( un0 , un1 );

r = un0 / un1 ;      # ratio class0 to class1
p = dim( dataWithoutLabels )[1];    # number of features

totalErrorDouble = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );
totalErrorCV     = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );
totalErrorLOO    = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );
totalErrorPlugin = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );
totalErrorTrue   = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );

totalTimeDouble = array( 0 , dim = c( length(sampleSize) , repetition ) );
totalTimeCV     = array( 0 , dim = c( length(sampleSize) , repetition ) );
totalTimeLOO    = array( 0 , dim = c( length(sampleSize) , repetition ) );
totalTimePlugin = array( 0 , dim = c( length(sampleSize) , repetition ) );
totalTimeTrue   = array( 0 , dim = c( length(sampleSize) , repetition ) );


for ( counter1 in 1:length(sampleSize) ) {

currentSampleSize = sampleSize[counter1];

print ( sprintf("started doing computations on sampleSize of %i at %s" , currentSampleSize , as.character(Sys.time()) ) );

n0 = length( sampleNumbers[[counter1,1,1]] );
n1 = length( sampleNumbers[[counter1,1,2]] );
ns = c( n0, n1 );

alpha0 = n0 / ( n0 + n1 );
alpha1 = n1 / ( n0 + n1 );
alphas = cbind ( alpha0 , alpha1 );

for( counter2 in 1:repetition ) {

shuffledClass0 = sampleNumbers[[ counter1 , counter2 , 1 ]];
shuffledClass1 = sampleNumbers[[ counter1 , counter2 , 2 ]];

# print( sprintf("[n0 n1] is [%i %i], the input is [%i %i]" , n0, n1, length(shuffledClass0) , length(shuffledClass1) ) );

X0 = dataWithoutLabels[ , shuffledClass0 ];
X1 = dataWithoutLabels[ , shuffledClass1 ];

x0 = rowMeans( X0 );	  x1 = rowMeans( X1 );
xs = cbind( x0 , x1 );

if ( match( n0 , c ( 0 , 1 ) , -1 ) == -1 ) {
   C = ( n1 - 1 ) * cov( t(X1) ) / ( n0 + n1 - 2 );
} else if ( match( n1 , c( 0 , 1 ) , -1 ) == -1 ) {
   C = ( n0 - 1 ) * cov( t(X0) ) / ( n0 + n1 - 2 );
}  else {
   C = ( ( n0 - 1 ) * cov( t(X0) ) + ( n1 - 1 ) * cov( t(X1) ) ) / ( n0 + n1 - 2 );
}

C = as.matrix( C );

XX0 = dataWithLabels[ , shuffledClass0 ];
XX1 = dataWithLabels[ , shuffledClass1 ];

trnData = cbind( dataWithLabels[ ,  shuffledClass0 ] , dataWithLabels[ ,  shuffledClass1 ] );
tstData = cbind( dataWithLabels[ , -shuffledClass0 ] , dataWithLabels[ , -shuffledClass1 ] );

t1 = proc.time();
errorDouble = estimateErrorDouble ( X0 , X1 , C , xs , ns , alphas , p , kappa , gammaValues, checkValue );
t2 = proc.time();
errorCV = CV( XX0 , XX1 , 5 , 5 , kappa , gammaValues , checkValue );
t3 = proc.time();
errorLOO = loo( trnData , kappa , gammaValues , checkValue , classes , alphas );
t4 = proc.time();
errorPlugin = plugin_lda( X0 , X1 , C , xs , alphas , p , kappa , gammaValues , checkValue );
t5 = proc.time();
errorTrue = estimateTrueError( trnData , tstData , kappa , gammaValues , checkValue , alphas );
t6 = proc.time();

totalTimeDouble[ counter1 , counter2 ] = t2[3] - t1[3];
totalTimeCV    [ counter1 , counter2 ] = t3[3] - t2[3];
totalTimeLOO   [ counter1 , counter2 ] = t4[3] - t3[3];
totalTimePlugin[ counter1 , counter2 ] = t5[3] - t4[3];
totalTimeTrue  [ counter1 , counter2 ] = t6[3] - t5[3];

totalErrorDouble[ counter2 , , counter1 ] = errorDouble;
totalErrorCV    [ counter2 , , counter1 ] = errorCV;
totalErrorLOO   [ counter2 , , counter1 ] = errorLOO;
totalErrorPlugin[ counter2 , , counter1 ] = errorPlugin;
totalErrorTrue  [ counter2 , , counter1 ] = errorTrue;

}

print ( sprintf("finished computations on sampleSize of %i at %s" , currentSampleSize , as.character(Sys.time()) ) );

}

finishTime = proc.time();
print( finishTime - startTime );

synth_totalTimeDouble = totalTimeDouble;
synth_totalTimeCV     = totalTimeCV    ;
synth_totalTimeLOO    = totalTimeLOO   ;
synth_totalTimePlugin = totalTimePlugin;
synth_totalTimeTrue   = totalTimeTrue  ;

synth_totalErrorDouble = totalErrorDouble;
synth_totalErrorCV     = totalErrorCV    ;
synth_totalErrorLOO    = totalErrorLOO   ;
synth_totalErrorPlugin = totalErrorPlugin;
synth_totalErrorTrue   = totalErrorTrue  ;

if ( myRun == "test" ) {
save( list=ls(all=TRUE) , file= sprintf( "test_synthCompData_%s.RData" , as.character( Sys.Date() ) ) );
} else if ( myRun == "real" ) {
save( list=ls(all=TRUE) , file= sprintf( "synthCompData_%s.RData" , as.character( Sys.Date() ) ) );
}

}