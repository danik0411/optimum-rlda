# read and analyse sonar.txt
# rm(list=ls(all=TRUE))	# clear all environments

applyAllEstimators = function( data_filename , gammaValues , sampleSize , checkValue=0, kappa=1 , filename , mode="test" , pathToSave = "" , appendName = "" ) {

startTime = proc.time();

source("double.R");
source("CV.R");
source("plugin.R")
source("loo.R");
source("trueError.R");

myEnv = new.env();	# store functions in this environment

environment( CV ) = myEnv;
environment( estimateErrorDouble ) = myEnv;
environment( RLDAvalue ) = myEnv;
environment( estimateD ) = myEnv;
environment( estimateTrueError ) = myEnv;
environment( LABELS_FROM_LDA_FUNCTION ) = myEnv;
environment( compareClassifierOutputs ) = myEnv;
environment( loo ) = myEnv;
environment( plugin_lda ) = myEnv;

print ( "gammaValues is:" );
print( gammaValues );
print( "sampleSize is:");
print( sampleSize ) ;
print( sprintf( "checkValue is %.3f, kappa is %.3f" , checkValue , kappa ));

load( data_filename );

rows = dim( Data )[1];
uns = dim( Data )[2];

classes = c( 0 , 1 );

dataWithLabels = Data;
dataWithoutLabels = Data[ -rows , ];

labelRow = Data[rows , ];

sample0 = which( labelRow %in% classes[1] );	# position of class0 in data
sample1 = which( labelRow %in% classes[2] );	# position of class1 in data

un0 = length( sample0 );
un1 = length( sample1 );
uns = c ( un0 , un1 );

r = un0 / un1 ;      # ratio class0 to class1
p = dim( dataWithoutLabels )[1];    # number of features

totalErrorDouble = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );
totalErrorCV     = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );
totalErrorLOO    = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );
totalErrorPlugin = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );
totalErrorTrue   = array( 0 , dim = c( repetition, length( gammaValues ) , length(sampleSize) ) );

totalTimeDouble = array( 0 , dim = c( length(sampleSize) , repetition ) );
totalTimeCV     = array( 0 , dim = c( length(sampleSize) , repetition ) );
totalTimeLOO    = array( 0 , dim = c( length(sampleSize) , repetition ) );
totalTimePlugin = array( 0 , dim = c( length(sampleSize) , repetition ) );
totalTimeTrue   = array( 0 , dim = c( length(sampleSize) , repetition ) );


for ( counter1 in 1:length(sampleSize) ) {

currentSampleSize = sampleSize[counter1];

print ( sprintf("started doing computations on sampleSize of %i at %s" , currentSampleSize , as.character(Sys.time()) ) );

n0 = length( sampleNumbers[[counter1,1,1]] );
n1 = length( sampleNumbers[[counter1,1,2]] );
ns = c( n0, n1 );

alpha0 = n0 / ( n0 + n1 );
alpha1 = n1 / ( n0 + n1 );
alphas = cbind ( alpha0 , alpha1 );

for( counter2 in 1:repetition ) {

shuffledClass0 = sampleNumbers[[ counter1 , counter2 , 1 ]];
shuffledClass1 = sampleNumbers[[ counter1 , counter2 , 2 ]];

# print( sprintf("[n0 n1] is [%i %i], the input is [%i %i]" , n0, n1, length(shuffledClass0) , length(shuffledClass1) ) );

X0 = dataWithoutLabels[ , shuffledClass0 ];
X1 = dataWithoutLabels[ , shuffledClass1 ];

x0 = rowMeans( X0 );	  x1 = rowMeans( X1 );
xs = cbind( x0 , x1 );

if ( match( n0 , c ( 0 , 1 ) , -1 ) == -1 ) {
   C = ( n1 - 1 ) * cov( t(X1) ) / ( n0 + n1 - 2 );
} else if ( match( n1 , c( 0 , 1 ) , -1 ) == -1 ) {
   C = ( n0 - 1 ) * cov( t(X0) ) / ( n0 + n1 - 2 );
}  else {
   C = ( ( n0 - 1 ) * cov( t(X0) ) + ( n1 - 1 ) * cov( t(X1) ) ) / ( n0 + n1 - 2 );
}

C = as.matrix( C );

XX0 = dataWithLabels[ , shuffledClass0 ];
XX1 = dataWithLabels[ , shuffledClass1 ];

trnData = cbind( dataWithLabels[ ,  shuffledClass0 ] , dataWithLabels[ ,  shuffledClass1 ] );
tstData = cbind( dataWithLabels[ , -shuffledClass0 ] , dataWithLabels[ , -shuffledClass1 ] );

t1 = proc.time();
errorDouble = estimateErrorDouble ( X0 , X1 , C , xs , ns , alphas , p , kappa , gammaValues, checkValue );
t2 = proc.time();
errorCV = CV( XX0 , XX1 , 5 , 5 , kappa , gammaValues , checkValue );
t3 = proc.time();
errorLOO = loo( trnData , kappa , gammaValues , checkValue , classes , alphas );
t4 = proc.time();
errorPlugin = plugin_lda( X0 , X1 , C , xs , alphas , p , kappa , gammaValues , checkValue );
t5 = proc.time();
errorTrue = estimateTrueError( trnData , tstData , kappa , gammaValues , checkValue , alphas );
t6 = proc.time();

totalTimeDouble[ counter1 , counter2 ] = t2[3] - t1[3];
totalTimeCV    [ counter1 , counter2 ] = t3[3] - t2[3];
totalTimeLOO   [ counter1 , counter2 ] = t4[3] - t3[3];
totalTimePlugin[ counter1 , counter2 ] = t5[3] - t4[3];
totalTimeTrue  [ counter1 , counter2 ] = t6[3] - t5[3];

totalErrorDouble[ counter2 , , counter1 ] = errorDouble;
totalErrorCV    [ counter2 , , counter1 ] = errorCV;
totalErrorLOO   [ counter2 , , counter1 ] = errorLOO;
totalErrorPlugin[ counter2 , , counter1 ] = errorPlugin;
totalErrorTrue  [ counter2 , , counter1 ] = errorTrue;

}

print ( sprintf("finished computations on sampleSize of %i at %s" , currentSampleSize , as.character(Sys.time()) ) );

}

finishTime = proc.time();
print( sprintf("the process took %.3f seconds (%.3f hours)" , (finishTime[3] - startTime[3]) , (finishTime[3] - startTime[3] )/3600 ) );

totalFileName = sprintf( "%s%s%s.RData" , pathToSave , filename , appendName );

print( sprintf( "saving results to %s" , totalFileName ) );

save( list=ls(all=TRUE) , file=totalFileName );
cat("\n\n");


}